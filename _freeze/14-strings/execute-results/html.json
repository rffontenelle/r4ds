{
  "hash": "93faf5daa42c5fa668a4896ec5445d6b",
  "result": {
    "markdown": "# Cadenas de caracteres\n\n## Introducción\n\nEste capítulo te introduce en la manipulación de cadenas de caracteres en R. Si bien aprenderás los aspectos básicos acerca de cómo funcionan y cómo crearlas a mano, el foco del capítulo estará puesto en las expresiones regulares (o _regex_). Como las cadenas de caracteres suelen contener datos no estructurados o semiestructurados, las expresiones regulares resultan útiles porque permiten describir patrones en ellas a través de un lenguaje conciso. Cuando mires por primera vez una expresión regular te parecerá que un gato caminó sobre tu teclado, pero a medida que vayas ampliando tu conocimiento pronto te empezarán a hacer sentido. \n\n### Prerequisitos\n\nEste capítulo se enfocará en el paquete para manipulación de cadenas llamado __stringr__ (del inglés _string_, cadena), que es parte del Tidyverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(datos)\n```\n:::\n\n\n## Cadenas: elementos básicos\n\nPuedes crear una cadena utilizando comillas simples o dobles. A diferencia de otros lenguajes, no hay diferencias en su comportamiento. Nuestra recomendación es siempre utilizar `\"`, a menos que quieras crear una cadena que contenga múltiples `\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring1 <- \"Esta es una cadena de caracteres\"\nstring2 <- 'Si quiero incluir \"comillas\" dentro de la cadena, uso comillas simples'\n```\n:::\n\n\nSi olvidas cerrar las comillas, verás un `+` en la consola, que es el signo de continuación para indicar que el código no está completo:\n\n```\n> \"Esta es una cadena de caracteres sin comillas de cierre\n+ \n+ \n+ AYUDA, ESTOY ATASCADO\n```\n\nSi esto te ocurre, ¡presiona la tecla _Escape_ e inténtalo de nuevo!\n\nPara incluir comillas simples o dobles de manera literal en una cadena puedes utilizar `\\` para \"escaparlas\" (\"escapar\" viene de la tecla _escape_):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomilla_doble <- \"\\\"\" # o '\"'\ncomilla_simple <- '\\'' # o \"'\"\n```\n:::\n\n\nEsto quiere decir que si quieres incluir una barra invertida, necesitas duplicarla: `\"\\\\\"`.\n\nTen cuidado con el hecho de que la representación impresa de una cadena no es equivalente a la cadena misma, ya que la representación muestra las barras utilizadas para \"escapar\" caracteres, es decir, para sean interpretados en su sentido literal, no como caracteres especiales. Para ver el contenido en bruto de una cadena utiliza `writeLines()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"\\\"\", \"\\\\\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"\\\"\" \"\\\\\"\n```\n:::\n\n```{.r .cell-code}\nwriteLines(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\"\n\\\n```\n:::\n:::\n\n\nExiste una serie de otros caracteres especiales. Los más comunes son `\"\\n\"`, para salto de línea, y `\"\\t\"`, para tabulación. Puedes ver la lista completa pidiendo ayuda acerca de `\"`: `?'\"'` o `?\"'\"`. A veces también verás cadenas del tipo `\"\\u00b5\"`, que es la manera de escribir caracteres que no están en inglés para que funcionen en todas las plataformas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"\\u00b5\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"µ\"\n```\n:::\n:::\n\n\nUsualmente se guardan múltiples cadenas en un vector de caracteres. Puedes crearlo usando `c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"uno\", \"dos\", \"tres\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"uno\"  \"dos\"  \"tres\"\n```\n:::\n:::\n\n\n### Largo de cadena\n\nR base tiene muchas funciones para trabajar con cadenas de caracteres, pero las evitaremos porque pueden ser incosistentes, lo que hace que sean difíciles de recordar. En su lugar, utilizaremos funciones del paquete __stringr__. Estas tienen nombres más intuitivos y todas empienzan con `str_`. Por ejemplo, `str_length()` te dice el número de caracteres de una cadena (_length_ en inglés es _largo_): \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_length(c(\"a\", \"R para Ciencia de Datos\", NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 23 NA\n```\n:::\n:::\n\n\nEl prefijo común `str_` es particularmente útil si utilizas RStudio, ya que al escribir `str_` se activa el autocompletado, lo que te permite ver todas las funciones de __stringr__:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](screenshots/stringr-autocomplete.png){width=678}\n:::\n:::\n\n\n### Combinar cadenas\n\nPara combinar dos o más cadenas utiliza `str_c()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(\"x\", \"y\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"xy\"\n```\n:::\n\n```{.r .cell-code}\nstr_c(\"x\", \"y\", \"z\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"xyz\"\n```\n:::\n:::\n\n\nUsa el argumento `sep` para controlar cómo separlas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(\"x\", \"y\", sep = \", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x, y\"\n```\n:::\n:::\n\n\nAl igual que en muchas otras funciones de R, los valores faltantes son contagiosos. Si quieres que se impriman como `\"NA\"`, utiliza `str_replace_na()` (_replace_ = remplazar):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"abc\", NA)\nstr_c(\"|-\", x, \"-|\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"|-abc-|\" NA       \n```\n:::\n\n```{.r .cell-code}\nstr_c(\"|-\", str_replace_na(x), \"-|\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"|-abc-|\" \"|-NA-|\" \n```\n:::\n:::\n\n\nComo se observa arriba, `str_c()` es una función vectorizada que automáticamente recicla los vectores más cortos hasta alcanzar la extensión del más largo: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(\"prefijo-\", c(\"a\", \"b\", \"c\"), \"-sufijo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"prefijo-a-sufijo\" \"prefijo-b-sufijo\" \"prefijo-c-sufijo\"\n```\n:::\n:::\n\n\nLos objetos de extensión 0 se descartan de manera silenciosa. Esto es particularmente útil en conjunto con `if` (_si_):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnombre <- \"Hadley\"\nhora_del_dia <- \"mañana\"\ncumpleanios <- FALSE\n\nstr_c(\n  \"Que tengas una buena \", hora_del_dia, \", \", nombre,\n  if (cumpleanios) \" y ¡FELIZ CUMPLEAÑOS!\",\n  \".\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Que tengas una buena mañana, Hadley.\"\n```\n:::\n:::\n\n\nPara colapsar un vector de cadenas en una sola, utiliza `collapse`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(c(\"x\", \"y\", \"z\"), collapse = \", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x, y, z\"\n```\n:::\n:::\n\n\n### Dividir cadenas\n\nPuedes extraer partes de una cadena utilizando `str_sub()`. Al igual que la cadena, `str_sub()` tiene como argumentos `start` (_inicio_) y `end` (_fin_), que indican la posición (inclusiva) del subconjunto que se quiere extraer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"Manzana\", \"Plátano\", \"Pera\")\nstr_sub(x, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Man\" \"Plá\" \"Per\"\n```\n:::\n\n```{.r .cell-code}\n# los números negativos cuentan de manera invertida desde el final\nstr_sub(x, -3, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ana\" \"ano\" \"era\"\n```\n:::\n:::\n\n\nTen en cuenta que `str_sub()` no fallará si la cadena es muy corta; simplemente devolverá todo lo que sea posible: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(\"a\", 1, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n:::\n\n\nTambién puedes utilizar `str_sub()` en forma de asignación para modificar una cadena: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"manzana\" \"plátano\" \"pera\"   \n```\n:::\n:::\n\n\n### _Locales_\n\nArriba utilizamos `str_to_lower()` para cambiar el texto a minúsculas. También puedes utilizar `str_to_upper()` o `str_to_title()`, si quieres modificar el texto a mayúsculas o formato título, respectivamente. Sin embargo, este tipo de cambios puede ser más complicado de lo parece a primera vista, ya que las reglas no son iguales en todos los idiomas. Puedes selecionar qué tipo de reglas aplicar especificando el entorno local o _locale_:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# La lengua turca tiene dos i: una con punto y otra sin punto\n# Tienen diferentes reglas para convertirlas en mayúsculas\n\nstr_to_upper(c(\"i\", \"ı\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I\" \"I\"\n```\n:::\n\n```{.r .cell-code}\nstr_to_upper(c(\"i\", \"ı\"), locale = \"tr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"İ\" \"I\"\n```\n:::\n:::\n\n\nEl entorno local o _locale_ se especifica con un código de idioma ISO 639, que es una abreviación de dos letras. Si todavía no conoces el código para tu idioma, en [Wikipedia](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) puedes encontrar una buena lista. Si dejas el _locale_ en blanco, se aplicará el que estés utilizando actualmente, que es provisto por tu sistema operativo. \n\nOtra operación importante que es afectada por el _locale_ es ordenar. Las funciones `order()` y `sort()` de R base ordenan las cadenas usando el _locale_ actual. Si quieres un comportamiento consistente a través de diferentes computadoras, sería preferible usar `str_sort()` y `str_order()`, que aceptan un argumento adicional para definir el `locale`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"arándano\", \"espinaca\", \"banana\")\n\nstr_sort(x, locale = \"es\")  # Español\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"arándano\" \"banana\"   \"espinaca\"\n```\n:::\n\n```{.r .cell-code}\nstr_sort(x, locale = \"haw\") # Hawaiano\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"arándano\" \"espinaca\" \"banana\"  \n```\n:::\n:::\n\n\n### Ejercicios\n\n1.  En ejemplos de código en los que no se utiliza __stringr__, verás usualmente `paste()` y `paste0()` (_paste_ = pegar).\n    ¿Cuál es la diferencia entre estas dos funciones? ¿A qué función de __stringr__ son equivalentes? ¿Cómo difieren estas dos funciones respecto de su manejo de los\n    `NA`?\n    \n1.  Describe con tus propias palabras la diferencia entre los argumentos `sep` y `collapse`\n    de la función `str_c()`.\n\n1.  Utiliza `str_length()` y `str_sub()` para extraer el caracter del medio de una cadena. ¿Qué harías si el número de caracteres es par?\n\n1.  ¿Qué hace `str_wrap()`? (_wrap_ = envolver) ¿Cuándo podrías querer utilizarla?\n\n1.  ¿Qué hace `str_trim()`? (_trim_ = recortar) ¿Cuál es el opuesto de `str_trim()`?\n\n1.  Escribe una función que convierta, por ejemplo, el vector `c(\"a\", \"b\", \"c\")` en\n    la cadena `a, b y c`. Piensa con detención qué debería hacer \n    dado un vector de largo 0, 1 o 2.\n\n### Buscar coincidencia de patrones con expresiones regulares\n\nLas expresiones regulares son un lenguaje conciso que te permite describir patrones en cadenas de caracteres. Toma un tiempo entenderlas, pero una vez que lo hagas te darás cuenta que son extremadamente útiles. \n\nPara aprender sobre expresiones regulares usaremos `str_view()` y `str_view_all()` (_view_ = ver). Estas funciones toman un vector de caracteres y una expresión regular y te muestran cómo coinciden. Partiremos con expresiones regulares simples que gradualmente se irán volviendo más y más complejas. Una vez que domines la coincidencia de patrones, aprenderás cómo aplicar estas ideas con otras funciones de __stringr__. \n\n### Coincidencias básicas\n\nLos patrones más simples buscan coincidencias con cadenas exactas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"manzana\", \"banana\", \"pera\")\nstr_view(x, \"an\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ m<an>z<an>a\n[2] │ b<an><an>a\n```\n:::\n:::\n\n\nEl siguiente paso en complejidad es `.`, que coincide con cualquier caracter (excepto un salto de línea):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, \".a.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <man><zan>a\n[2] │ <ban>ana\n```\n:::\n:::\n\n\nPero si \"`.`\" coincide con cualquier caracter, ¿cómo buscar una coincidencia con el caracter \"`.`\"? Necesitas utilizar un \"escape\" para decirle a la expresión regular que quieres hacerla coincidir de manera exacta, no usar su comportamiento especial. Al igual que en las cadenas, las expresiones regulares usan la barra invertida, `\\`, para \"escapar\" los comportamientos especiales. Por lo tanto, para hacer coincidir un `.`, necesitas la expresión regular `\\.`. Lamentablemente, esto crea una problema. Estamos usando cadenas para representar una expresión regular y en ellas  `\\` también se usa como símbolo de \"escape\". Por lo tanto, para crear la expresión regular `\\.` necesitamos la cadena `\"\\\\.\"`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Para crear una expresión regular necesitamos \\\\\npunto <- \"\\\\.\"\n\n# Pero la expresión en sí misma solo contiene una \\\nwriteLines(punto)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\\.\n```\n:::\n\n```{.r .cell-code}\n# Esto le dice a R que busque el . de manera explícita\nstr_view(c(\"abc\", \"a.c\", \"bef\"), \"a\\\\.c\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2] │ <a.c>\n```\n:::\n:::\n\n\nSi `\\` se utiliza para escapar un caracter en una expresión regular, ¿cómo coincidir de manera literal una `\\`? Bueno, necesitarías escaparla creando la expresión regular `\\\\`. Para crear esa expresión regular necesitas usar una cadena, que requiere también escapar la `\\`. Esto quiere decir que para coincidir literalmente `\\` necesitas escribir `\"\\\\\\\\\"` --- ¡necesitas cuatro barras invertidas para coincidir una! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"a\\\\b\"\nwriteLines(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\\b\n```\n:::\n\n```{.r .cell-code}\nstr_view(x, \"\\\\\\\\\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ a<\\>b\n```\n:::\n:::\n\n\nEn este libro escribiremos las expresiones regulares como `\\.` y las cadenas que representan a las expresiones regulares como `\"\\\\.\"`.\n\n#### Ejercicios\n\n1.  Explica por qué cada una de estas cadenas no coincide con `\\`: `\"\\\"`, `\"\\\\\"`, `\"\\\\\\\"`.\n\n1.  ¿Cómo harías coincidir la secuencia `\"'\\`?\n\n1.  ¿Con qué patrones coincidiría la expresión regular`\\..\\..\\..`? \n    ¿Cómo la representarías en una cadena?\n\n### Anclas\n\nPor defecto, las expresiones regulares buscarán una coincidencia en cualquier parte de una cadena. Suele ser útil _anclar_ una expresión regular para que solo busque coincidencias al inicio o al final. Puedes utilizar: \n\n* `^` para buscar la coincidencia al inicio de la cadena.\n* `$` para buscar la coincidencia al final de la cadena.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"arándano\", \"banana\", \"pera\")\nstr_view(x, \"^a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <a>rándano\n```\n:::\n\n```{.r .cell-code}\nstr_view(x, \"a$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2] │ banan<a>\n[3] │ per<a>\n```\n:::\n:::\n\n\nPara recordar cuál es cuál, puedes intentar este recurso mnemotécnico que aprendimos de [Evan Misshula](https://twitter.com/emisshula/status/323863393167613953): si empiezas con potencia (`^`), terminarás con dinero (`$`).\n\nPara forzar que una expresión regular coincida con una cadena completa, ánclala usando tanto `^` como `$`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"pie de manzana\", \"manzana\", \"queque de manzana\")\nstr_view(x, \"manzana\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ pie de <manzana>\n[2] │ <manzana>\n[3] │ queque de <manzana>\n```\n:::\n\n```{.r .cell-code}\nstr_view(x, \"^manzana$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2] │ <manzana>\n```\n:::\n:::\n\n\nTambién puedes coincidir el límite entre palabras con `\\b`. No utilizamos frecuentemente esta forma en R, pero sí a veces cuando buscamos en RStudio el nombre de una función que también compone el nombre de otras funciones. Por ejemplo, buscaríamos `\\bsum\\b` para evitar la coincidencia con `summarise`, `summary`, `rowsum` y otras.\n\n#### Ejercicios\n\n1.  ¿Cómo harías coincidir la cadena `\"$^$\"` de manera literal?\n\n1.  Dado el corpus de palabras comunes en `datos::palabras`, crea una expresión\n    regular que busque palabras que:\n    \n    1. Empiecen con \"y\".\n    1. Terminen con \"z\"\n    1. Tengan una extensión de exactamente tres letras. (¡No hagas trampa usando `str_length()`!)\n    1. Tengan ocho letras o más. \n\n    Dado que esta será una lista larga, podrías querer usar el argumento `match` en\n    `str_view()` para mostrar solo las palabras que coincidan o no coincidan. \n\n### Clases de caracteres y alternativas\n\nExiste una serie de patrones especiales que coinciden con más de un caracter. Ya has visto `.`, que coincide con cualquier caracter excepto un salto de línea. Hay otras cuatro herramientas que son de utilidad: \n\n* `\\d`: coincide con cualquier dígito.\n* `\\s`: coincide con cualquier espacio en blanco (por ejemplo, espacio simple, tabulador, salto de línea).\n* `[abc]`: coincide con a, b o c.\n* `[^abc]`: coincide con todo menos con a, b o c.\n\nRecuerda que para crear una expresión regular que contenga `\\d` o `\\s` necesitas escapar la `\\` en la cadena, por lo que debes escribir `\"\\\\d\"` o `\"\\\\s\"`.\n\nUtilizar una clase de caracter que contenga en su interior un solo caracter puede ser una buena alternativa a la barra invertida cuando quieres incluir un solo metacaracter en la expresión regular. Muchas personas encuentran que así es más fácil de leer. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Buscar de forma literal un caracter que usualmente tiene un significado especial en una expresión regular\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[.]c\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2] │ <a.c>\n```\n:::\n\n```{.r .cell-code}\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \".[*]c\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3] │ <a*c>\n```\n:::\n\n```{.r .cell-code}\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[ ]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4] │ <a >c\n```\n:::\n:::\n\n\nEsto funciona para la mayoría (pero no para todos) los metacaracteres de las expresiones regulares: `$` `.` `|` `?` `*` `+` `(` `)` `[` `{`. Desafortunadamente, existen unos pocos caracteres que tienen un significado especial incluso dentro de una clase de caracteres y deben manejarse con barras invertidas para escaparlos: `]` `\\` `^` y `-`.\n\nPuedes utiizar una _disyunción_ para elegir entre uno más patrones alternativos. Por ejemplo, `abc|d..a` concidirá tanto con '\"abc\"', como con `\"duna\"`. Ten en cuenta que la precedencia de `|` es baja, por lo que `abc|xyz` coincidirá con `abc` o `xyz`, no con `abcyz` o `abxyz`. Al igual que en expresiones matemáticas, si el valor de `|` se vuelve confuso, utiliza paréntesis para dejar claro qué es lo que quieres: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(c(\"cómo\", \"como\"), \"c(ó|o)mo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <cómo>\n[2] │ <como>\n```\n:::\n:::\n\n\n#### Ejercicios\n\n1.  Crea una expresión regular que encuentre todas las palabras que:\n\n    1. Empiecen con una vocal.\n\n    1. Solo contengan consonantes. (Pista: piensa en cómo buscar coincidencias para \n       \"no\"-vocales.)\n\n    1. Terminen en `ón`, pero no en `ión`.\n    \n    1. Terminen con `ndo` o `ado`.\n    \n\n1.  ¿Siempre a una \"q\" la sigue una \"u\"?\n\n1.  Escribe una expresión regular que permita buscar un verbo que haya sido escrito usando voseo en segunda persona plural  \n    (por ejemplo, _queréis_ en vez de _quieren_).\n\n1.  Crea una expresión regular que coincida con la forma en que habitualmente \n    se escriben los números de teléfono en tu país.\n    \n1. En inglés existe una regla que dice que la letra i va siempre antes de la e, excepto cuando está después de una c\". Verifica empíricamente esta regla utilizando las palabras contenidas en `stringr::words`. \n\n\n### Repetición\n\nEl siguiente paso en términos de poder implica controlar cuántas veces queremos que se encuentre un patrón:\n\n* `?`: 0 o 1\n* `+`: 1 o más\n* `*`: 0 o más\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"1888 es el año más largo en números romanos: MDCCCLXXXVIII\"\nstr_view(x, \"CC?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ 1888 es el año más largo en números romanos: MD<CC><C>LXXXVIII\n```\n:::\n\n```{.r .cell-code}\nstr_view(x, \"CC+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ 1888 es el año más largo en números romanos: MD<CCC>LXXXVIII\n```\n:::\n\n```{.r .cell-code}\nstr_view(x, 'C[LX]+')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ 1888 es el año más largo en números romanos: MDCC<CLXXX>VIII\n```\n:::\n:::\n\n\nTen en cuenta que la precedencia de este operador es alta, por lo que puedes escribir: `cantái?s` para encontrar tanto voseo americano como de la variante peninsular del español (es decir, _cantás_ y _cantáis_). Esto quiere decir que en la mayor parte de los usos se necesitarán paréntesis, como `bana(na)+`.\n\nTambién puedes especificar el número de coincidencias que quieres encontrar de manera precisa:\n\n* `{n}`: exactamente n\n* `{n,}`: n o más\n* `{,m}`: no más de m\n* `{n,m}`: entre n y m\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, \"C{2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ 1888 es el año más largo en números romanos: MD<CC>CLXXXVIII\n```\n:::\n\n```{.r .cell-code}\nstr_view(x, \"C{2,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ 1888 es el año más largo en números romanos: MD<CCC>LXXXVIII\n```\n:::\n\n```{.r .cell-code}\nstr_view(x, \"C{2,3}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ 1888 es el año más largo en números romanos: MD<CCC>LXXXVIII\n```\n:::\n:::\n\n\nPor defecto, este tipo de coincidencias son \"avaras\" (_greedy_): tratarán de coincidir con la cadena más larga posible. También puedes hacerlas \"perezosas\" (_lazy_) para que coincidan con la cadena más corta posible, poniendo un `?` después de ellas. Esta es una característica avanzada de las expresiones regulares, pero es útil saber que existe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(x, 'C{2,3}?')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ 1888 es el año más largo en números romanos: MD<CC>CLXXXVIII\n```\n:::\n\n```{.r .cell-code}\nstr_view(x, 'C[LX]+?')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ 1888 es el año más largo en números romanos: MDCC<CL>XXXVIII\n```\n:::\n:::\n\n\n#### Ejercicios\n\n1.  Describe los equivalentes de `?`, `+`, `*` en el formato `{m,n}`.\n\n1.  Describe en palabras con qué coincidiría cada una de estas expresiones regulares:\n    (lee con atención para ver si estamos utilizando una expresión regular o una cadena\n    que define una expresión regular.)\n\n    1. `^.*$`\n    1. `\"\\\\{.+\\\\}\"`\n    1. `\\d{4}-\\d{2}-\\d{2}`\n    1. `\"\\\\\\\\{4}\"`\n\n1.  Crea expresiones regulares para buscar todas las palabras que:\n\n    1. Empiecen con dos consonantes.\n    1. Tengan tres o más vocales seguidas.\n    1. Tengan tres o más pares de vocal-consonante seguidos. \n\n### Agrupamiento y referencias previas\n\nAnteriormente aprendiste sobre el uso de paréntesis para desambiguar expresiones complejas. Los paréntesis también sirven para crear un grupo de captura _numerado_ (número 1, 2, etc.). Un grupo de captura guarda _la parte de la cadena_ que coincide con la parte de la expresión regular entre paréntesis. Puedes referirte al mismo texto tal como fue guardado en un grupo de captura utilizando _referencias previas_, como `\\1`, `\\2` etc. Por ejemplo, la siguiente expresión regular busca todas las frutas que tengan un par de letras repetido. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(frutas, \"(..)\\\\1\", match = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] │ b<anan>a\n [2] │ <papa>ya\n [8] │ <anan>á\n[23] │ <coco>\n```\n:::\n:::\n\n\n(En breve, también verás cómo esto es útil en conjunto con `str_match()`.)\n\n#### Ejercicios\n\n1.  Describe en palabras con qué coinciden estas expresiones: \n\n    1. `(.)\\1\\1`\n    1. `\"(.)(.)\\\\2\\\\1\"`\n    1. `(..)\\1`\n    1. `\"(.).\\\\1.\\\\1\"`\n    1. `\"(.)(.)(.).*\\\\3\\\\2\\\\1\"`\n\n1.  Construye una expresión regular que coincida con palabras que: \n\n    1. Empiecen y terminen con el mismo caracter. \n    \n    1. Contengan un par de letras repetido\n       (p. ej. \"nacional\" tiene \"na\" repetido dos veces.)\n    \n    1. Contengan una letra repetida en al menos tres lugares\n       (p. ej. \"característica\" tiene tres \"a\".)\n\n## Herramientas\n\nAhora que has aprendido los elementos básicos de las expresiones regulares, es tiempo de aprender cómo aplicarlos en problemas reales. En esta sección aprenderás una amplia variedad de funciones de __stringr__ que te permitirán:\n\n* Determinar qué cadenas coinciden con un patrón.\n* Encontrar la posición de una coincidencia.\n* Extraer el contenido de las coincidencias.\n* Remplazar coincidencias con nuevos valores.\n* Dividir una cadena de acuerdo a una coincidencia.\n\nUna advertencia antes de continuar: debido a que las expresiones regulares son tan poderosas, es fácil intentar resolver todos los problemas con una sola expresión regular. En palabras de Jamie Zawinski:\n\n> Cuando se enfrentan a un problema, algunas personas piensan “Lo sé, usaré expresiones\n> regulares.” Ahora tienen dos problemas. \n\nComo advertencia, revisa esta expresión regular que chequea si una dirección de correo electrónico es válida:\n\n```\n(?:(?:\\r\\n)?[ \\t])*(?:(?:(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t]\n)+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\n\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(\n?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \n\\t]))*\"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\0\n31]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\\n](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+\n(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:\n(?:\\r\\n)?[ \\t])*))*|(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z\n|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)\n?[ \\t])*)*\\<(?:(?:\\r\\n)?[ \\t])*(?:@(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\\nr\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[\n \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)\n?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t]\n)*))*(?:,@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[\n \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*\n)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t]\n)+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*)\n*:(?:(?:\\r\\n)?[ \\t])*)?(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+\n|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\n\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\n\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t\n]))*\"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031\n]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](\n?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?\n:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?\n:\\r\\n)?[ \\t])*))*\\>(?:(?:\\r\\n)?[ \\t])*)|(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?\n:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?\n[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)*:(?:(?:\\r\\n)?[ \\t])*(?:(?:(?:[^()<>@,;:\\\\\".\\[\\] \n\\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\n\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>\n@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"\n(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t]\n)*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\n\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?\n:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\n\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*|(?:[^()<>@,;:\\\\\".\\[\\] \\000-\n\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(\n?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)*\\<(?:(?:\\r\\n)?[ \\t])*(?:@(?:[^()<>@,;\n:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([\n^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\"\n.\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\\n]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*(?:,@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\\n[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\\nr\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \n\\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]\n|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*)*:(?:(?:\\r\\n)?[ \\t])*)?(?:[^()<>@,;:\\\\\".\\[\\] \\0\n00-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\\n.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,\n;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?\n:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t])*\n(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\n\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[\n^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]\n]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*\\>(?:(?:\\r\\n)?[ \\t])*)(?:,\\s*(\n?:(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\n\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(\n?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\n\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t\n])*))*@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t\n])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?\n:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\n\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*|(?:\n[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\\n]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)*\\<(?:(?:\\r\\n)\n?[ \\t])*(?:@(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"\n()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)\n?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>\n@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*(?:,@(?:(?:\\r\\n)?[\n \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,\n;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t]\n)*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\n\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*)*:(?:(?:\\r\\n)?[ \\t])*)?\n(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\n\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\n\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\n\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])\n*))*@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])\n+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\\n.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z\n|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*\\>(?:(\n?:\\r\\n)?[ \\t])*))*)?;\\s*)\n```\n\nEn cierto sentido, este es un ejemplo \"patológico\" (porque las direcciones de correo electrónico son de verdad sorpresivamente complejas), pero se usa en código real. Mira esta discusión (en inglés) en Stack Overflow <http://stackoverflow.com/a/201378> para más detalles. \n\nNo olvides que estás trabajando en un lenguaje de programación y que tienes otras herramientas a tu disposición. En vez de crear una sola expresión regular compleja, usualmente es más fácil crear una serie de expresiones regulares más simples. Si te atascaste tratando de crear una sola expresión regular que resuelva tu problema, da un paso atrás y piensa cómo podrías dividir el problema en partes más pequeñas. Esto te permitirá ir resolviendo cada desafío antes de moverte al siguiente. \n\n### Detectar coincidencias\n\nPara determinar si un vector de caracteres coincide con un patrón de búsqueda, puedes utilizar `str_detect()`. Este devuelve un vector lógico del mismo largo que el _input_:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"manzana\", \"plátano\", \"pera\")\nstr_detect(x, \"e\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE\n```\n:::\n:::\n\n\nRecuerda que cuando usas vectores lógicos en un contexto numérico, `FALSE` (_falso_) se convierte en 0 y `TRUE` (_verdadero_) se convierte en 1. Eso hace que `sum()` (_suma_) y `mean()` (_media_) sean funciones útiles si quieres responder preguntas sobre coincidencias a lo largo de un vector más extenso: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ¿Cuántas palabras comunes empiezan con m?\nsum(str_detect(palabras, \"^m\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 81\n```\n:::\n\n```{.r .cell-code}\n# ¿Qué proporción de palabras comunes terminan con una vocal?\nmean(str_detect(palabras, \"[aáeéiéoéuú]$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.546\n```\n:::\n:::\n\n\n\nCuando tienes condiciones lógicas complejas, (p. ej., encontrar _a_ o _b_ pero no _c_, salvo que _d_) suele ser más fácil combinar múltiples llamadas a `str_detect()` con operadores lógicos, que tratar de crear una sola expresión regular. Por ejemplo, hay dos maneras de buscar todas las palabras que no contengan ninguna vocal: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Encuentra todas las palabras que contengan al menos una vocal, y luego niégalo\nsin_vocales_1 <- !str_detect(palabras, \"[aáeéiíoóuúúü]\")\n# Encuentra todas las palabras consistentes solo en consonantes (no vocales)\nsin_vocales_2 <- str_detect(palabras, \"^[^aáeéiíoóuúúü]+$\")\nidentical(sin_vocales_1, sin_vocales_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nLos resultados son idénticos; sin embargo, creemos que la primera aproximación es significativamente más fácil de entender. Si tu expresión regular se vuelve extremadamente compleja, trata de dividirla en partes más pequeñas, dale un nombre a cada parte y luego combínalas en operaciones lógicas. \n\nUn uso común de `str_detect()` es para seleccionar elementos que coincidan con un patrón. Puedes hacer eso con subdivisiones lógicas o utilizando `str_subset()`, que es un \"envoltorio\" (_wrapper_) de esas operaciones. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npalabras[str_detect(palabras, \"x$\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ex\"\n```\n:::\n\n```{.r .cell-code}\nstr_subset(palabras, \"x$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ex\"\n```\n:::\n:::\n\n\nEn todo caso, lo más habitual es que tus cadenas de caracteres sean una columna de un _data frame_ y que prefieras utilizar la función `filter()` (_filtrar_):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  palabra = palabras, \n  i = seq_along(palabra)\n)\ndf %>% \n  filter(str_detect(palabras, \"x$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  palabra     i\n  <chr>   <int>\n1 ex        338\n```\n:::\n:::\n\n\n\nUna varación de `str_detect()` es `str_count()` (_count_ = contar): más que un simple sí o no, te indica cuántas coincidencias hay en una cadena:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"manzana\", \"plátano\", \"pera\")\nstr_count(x, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 1 1\n```\n:::\n\n```{.r .cell-code}\n# En promedio, ¿cuántas vocales hay por palabra?\nmean(str_count(palabras, \"[aáeéiíoóuúü]\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.72\n```\n:::\n:::\n\n\nEs natural usar `str_count()` junto con `mutate()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>% \n  mutate(\n    vocales = str_count(palabra, \"[aáeéiíoóuúü]\"),\n    consonantes = str_count(palabra, \"[^aáeéiíoóuúü]\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 4\n   palabra         i vocales consonantes\n   <chr>       <int>   <int>       <int>\n 1 a               1       1           0\n 2 abril           2       2           3\n 3 acción          3       3           3\n 4 acciones        4       4           4\n 5 acerca          5       3           3\n 6 actitud         6       3           4\n 7 actividad       7       4           5\n 8 actividades     8       5           6\n 9 acto            9       2           2\n10 actual         10       3           3\n# ℹ 990 more rows\n```\n:::\n:::\n\n\nTen en cuenta que las coincidencias nunca se superponen. Por ejemplo, en `\"abababa\"`, ¿cuántas veces se encontrará una coincidencia con el patrón `\"aba\"`? Las expresiones regulares dicen que dos, no tres:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_count(\"abababa\", \"aba\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nstr_view_all(\"abababa\", \"aba\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `str_view()` was deprecated in stringr 1.5.0.\nℹ Please use `str_view_all()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <aba>b<aba>\n```\n:::\n:::\n\n\nToma nota sobre el uso de `str_view_all()`. Como aprenderás dentro de poco, muchas funciones de __stringr__ vienen en pares: una función trabaja con una sola coincidencia y la otra con todas. La segunda función tendrá el sufijo `_all` (_todas_).\n\n### Ejercicios\n\n1.  Para cada uno de los siguientes desafíos, intenta buscar una solución utilizando tanto una \n    expresión regular simple como una combinación de múltiples llamadas a `str_detect()`.\n    \n    1.  Encuentra todas las palabras que empiezan o terminan con `y`.\n    \n    1.  Encuentra todas las palabras que empiezan con una vocal y terminan con una consonante.\n    \n    1.  ¿Existen palabras que tengan todas las vocales?\n\n1.  ¿Qué palabra tiene el mayor número de vocales? ¿Qué palabra tiene la mayor\n    proporción de vocales? (Pista: ¿cuál es el denominador?)\n\n### Extraer coincidencias\n\nPara extraer el texto de una coincidencia utiliza `str_extract()`. Para mostrar cómo funciona, necesitaremos un ejemplo más complicado. Para ello, usaremos una selección y adaptación al español de las oraciones disponibles originalmente en `stringr::sentences` y que puedes encontrar en `datos::oraciones`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(oraciones)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50\n```\n:::\n\n```{.r .cell-code}\nhead(oraciones)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Las casas están construidas de ladrillos de arcilla roja.\"\n[2] \"La caja fue arrojada al lado del camión estacionado.\"     \n[3] \"El domingo es la mejor parte de la semana.\"               \n[4] \"Agrega a la cuenta de la tienda hasta el último centavo.\" \n[5] \"Nueve hombres fueron contratados para excavar las ruinas.\"\n[6] \"Pega la hoja en el fondo azul oscuro.\"                    \n```\n:::\n:::\n\n\nImagina que quieres encontrar todas las oraciones que tengan el nombre de un color. Primero, creamos un vector con nombres de colores y luego lo convertimos en una sola expresión regular:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolores <- c(\"rojo\", \"amarillo\", \"verde\", \"azul\", \"marrón\")\ncoincidencia_color <- str_c(colores, collapse = \"|\")\ncoincidencia_color\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"rojo|amarillo|verde|azul|marrón\"\n```\n:::\n:::\n\n\nAhora, podemos seleccionar las oraciones que contienen un color y extraer luego el color para saber de cuál se trata:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntiene_color <- str_subset(oraciones, coincidencia_color)\ncoincidencia <- str_extract(tiene_color, coincidencia_color)\nhead(coincidencia)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"azul\"   \"azul\"   \"rojo\"   \"azul\"   \"azul\"   \"marrón\"\n```\n:::\n:::\n\n\nTen en cuenta que `str_extract()` solo extrae la primera coincidencia. Podemos ver eso de manera sencilla seleccionando primero todas las oraciones que tengan más de una coincidencia:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmas <- oraciones[str_count(oraciones, coincidencia_color) > 1]\nstr_view_all(mas, coincidencia_color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ Instalaron <azul>ejos <verde>s en la cocina.\n[2] │ Si ar<rojo> la taza <azul> al suelo se romperá.\n[3] │ Las hojas se vuelven de color <marrón> y <amarillo> en el otoño.\n[4] │ La luz <verde> en la caja <marrón> parpadeaba.\n```\n:::\n\n```{.r .cell-code}\nstr_extract(mas, coincidencia_color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"azul\"   \"rojo\"   \"marrón\" \"verde\" \n```\n:::\n:::\n\n\nEste es un patrón de coincidencia común para las funciones de __stringr__, ya que trabajar con una sola coincidencia te permite utilizar estructuras de datos más simples. Para obtener todas las coincidencias, utiliza `str_extract_all()`. Esta función devuelve una lista:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract_all(mas, coincidencia_color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"azul\"  \"verde\"\n\n[[2]]\n[1] \"rojo\" \"azul\"\n\n[[3]]\n[1] \"marrón\"   \"amarillo\"\n\n[[4]]\n[1] \"verde\"  \"marrón\"\n```\n:::\n:::\n\n\nAprenderás más sobre listas en el capítulo sobre [vectores] y en el sobre [iteración].\n\nSi utilizas `simplify = TRUE` (es decir, _simplificar_ = VERDADERO), `str_extract_all()` devolverá una matriz con las coincidencias más cortas expandidas hasta el largo de las más extensas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_extract_all(mas, coincidencia_color, simplify = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]     [,2]      \n[1,] \"azul\"   \"verde\"   \n[2,] \"rojo\"   \"azul\"    \n[3,] \"marrón\" \"amarillo\"\n[4,] \"verde\"  \"marrón\"  \n```\n:::\n\n```{.r .cell-code}\nx <- c(\"a\", \"a b\", \"a b c\")\nstr_extract_all(x, \"[a-z]\", simplify = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,] \"a\"  \"\"   \"\"  \n[2,] \"a\"  \"b\"  \"\"  \n[3,] \"a\"  \"b\"  \"c\" \n```\n:::\n:::\n\n\n#### Ejercicios\n\n1.  Te habrás dado cuenta que en el ejemplo anterior la expresión regular\n    que utilizamos también devolvió como resultado \"arrojo\" y \"azulejos\", \n    que no son nombres de colores. Modifica la expresión regular para \n    resolver ese problema.\n    \n\n1.  De `datos::oraciones` extrae:\n\n    1. La primera palabra de cada oración.\n    1. Todas las palabras que terminen en `ción`.\n    1. Todos los plurales.\n\n### Coincidencias agrupadas\n\nAntes en este capítulo hablamos sobre el uso de paréntesis para aclarar la _precedencia_ y las _referencias previas_ al buscar coincidencias. También puedes utilizar los paréntesis para extraer una coincidencia compleja. Por ejemplo, imagina que quieres extraer los sustantivos de una oración. Como heurística, buscaremos cualquier palabra que venga después de un artículo (_el_, _la_, _un_, _una_, etc.). Definir qué es una palabra en una expresión regular es un poco complicado, así que aquí utilizaremos una aproximación simple: una secuencia de al menos un caracter que no sea un espacio. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsustantivo <- \"(el|la|los|las|lo|un|una|unos|unas) ([^ ]+)\"\n\ntiene_sustantivo <- oraciones %>%\n  str_subset(sustantivo) %>%\n  head(10)\ntiene_sustantivo %>% \n  str_extract(sustantivo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"los de\"      \"el camión\"   \"la mejor\"    \"la cuenta\"   \"las ruinas.\"\n [6] \"la hoja\"     \"la cocina.\"  \"la taza\"     \"el tanque.\"  \"el calor\"   \n```\n:::\n:::\n\n\n`str_extract()` nos devuelve la coincidencia completa; `str_match()` nos  entrega cada componente. En vez de un vector de caracteres, devuelve una matriz con una columna para la coincidencia completa y una columna para cada grupo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntiene_sustantivo %>% \n  str_match(sustantivo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]          [,2]  [,3]     \n [1,] \"los de\"      \"los\" \"de\"     \n [2,] \"el camión\"   \"el\"  \"camión\" \n [3,] \"la mejor\"    \"la\"  \"mejor\"  \n [4,] \"la cuenta\"   \"la\"  \"cuenta\" \n [5,] \"las ruinas.\" \"las\" \"ruinas.\"\n [6,] \"la hoja\"     \"la\"  \"hoja\"   \n [7,] \"la cocina.\"  \"la\"  \"cocina.\"\n [8,] \"la taza\"     \"la\"  \"taza\"   \n [9,] \"el tanque.\"  \"el\"  \"tanque.\"\n[10,] \"el calor\"    \"el\"  \"calor\"  \n```\n:::\n:::\n\n\n(Como era de esperarse, nuestra heurística para detectar sustantivos es pobre, ya que también selecciona adjetivos como \"mejor\" y preposiciones como \"de\").\n\nSi tus datos están en un tibble, suele ser más fácil utilizar `tidyr::extract()`. Funciona como `str_match()` pero requiere ponerle un nombre a las coincidencias, las que luego son puestas en columnas nuevas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(oracion = oraciones) %>% \n  tidyr::extract(\n    oracion, c(\"articulo\", \"sustantivo\"), \"(el|la|los|las|un|una|unos|unas) ([^ ]+)\", \n    remove = FALSE\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 × 3\n   oracion                                                   articulo sustantivo\n   <chr>                                                     <chr>    <chr>     \n 1 Las casas están construidas de ladrillos de arcilla roja. los      de        \n 2 La caja fue arrojada al lado del camión estacionado.      el       camión    \n 3 El domingo es la mejor parte de la semana.                la       mejor     \n 4 Agrega a la cuenta de la tienda hasta el último centavo.  la       cuenta    \n 5 Nueve hombres fueron contratados para excavar las ruinas. las      ruinas.   \n 6 Pega la hoja en el fondo azul oscuro.                     la       hoja      \n 7 Instalaron azulejos verdes en la cocina.                  la       cocina.   \n 8 Si arrojo la taza azul al suelo se romperá.               la       taza      \n 9 Dos peces azules nadaban en el tanque.                    el       tanque.   \n10 El ancho camino brillaba bajo el calor del sol.           el       calor     \n# ℹ 40 more rows\n```\n:::\n:::\n\n\nAl igual que con `str_extract()`, si quieres todas las coincidencias para cada cadena, tienes que utilizar `str_match_all()`.\n\n#### Ejercicios\n\n1. Busca en `datos::oraciones` todas las palabras que vengan después de un \"número\", como \"un(o|a)\", \"dos\", \"tres\", etc.\n   Extrae tanto el número como la palabra.\n\n1. En español a veces se utiliza el guión para unir adjetivos, establecer relaciones entre conceptos o para unir gentilicios (p. ej., _teórico-práctico_, _precio-calidad_, _franco-porteña_). ¿Cómo podrías encontrar esas palabras y separar lo que viene antes y después del guión?\n\n### Remplazar coincidencias\n\n`str_replace()` y `str_replace_all()` te permiten remplazar coincidencias en una nueva cadena. Su uso más simple es para remplazar un patrón con una cadena fija: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"manzana\", \"pera\", \"banana\")\nstr_replace(x, \"[aeiou]\", \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"m-nzana\" \"p-ra\"    \"b-nana\" \n```\n:::\n\n```{.r .cell-code}\nstr_replace_all(x, \"[aeiou]\", \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"m-nz-n-\" \"p-r-\"    \"b-n-n-\" \n```\n:::\n:::\n\n\nCon `str_replace_all()` puedes realizar múltiples remplazos a través de un vector cuyos elementos tiene nombre (_named vector_):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"1 casa\", \"2 autos\", \"3 personas\")\nstr_replace_all(x, c(\"1\" = \"una\", \"2\" = \"dos\", \"3\" = \"tres\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"una casa\"      \"dos autos\"     \"tres personas\"\n```\n:::\n:::\n\n\nEn vez de hacer remplazos con una cadena fija, puedes utilizar _referencias previas_ para insertar componentes de la coincidencia. En el siguiente código invertimos el orden de la segunda y la tercera palabra: \n\n\n::: {.cell}\n\n```{.r .cell-code}\noraciones %>% \n  str_replace(\"([^ ]+) ([^ ]+) ([^ ]+)\", \"\\\\1 \\\\3 \\\\2\") %>% \n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Las están casas construidas de ladrillos de arcilla roja.\"\n[2] \"La fue caja arrojada al lado del camión estacionado.\"     \n[3] \"El es domingo la mejor parte de la semana.\"               \n[4] \"Agrega la a cuenta de la tienda hasta el último centavo.\" \n[5] \"Nueve fueron hombres contratados para excavar las ruinas.\"\n```\n:::\n:::\n\n\n#### Ejercicios\n\n1.   Remplaza en una cadena todas las barras por barras invertidas.\n\n1.   Implementa una versón simple de `str_to_lower()` (_a minúsculas_) usando `replace_all()`.\n\n1.   Cambia la primera y la última letra en `palabras`. ¿Cuáles de esas cadenas\n     siguen siendo palabras?\n\n### Divisiones\n\nUsa `str_split()` para dividir una cadena en partes. Por ejemplo, podemos dividir `oraciones` en palabras:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noraciones %>%\n  head(5) %>% \n  str_split(\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"Las\"         \"casas\"       \"están\"       \"construidas\" \"de\"         \n[6] \"ladrillos\"   \"de\"          \"arcilla\"     \"roja.\"      \n\n[[2]]\n[1] \"La\"           \"caja\"         \"fue\"          \"arrojada\"     \"al\"          \n[6] \"lado\"         \"del\"          \"camión\"       \"estacionado.\"\n\n[[3]]\n[1] \"El\"      \"domingo\" \"es\"      \"la\"      \"mejor\"   \"parte\"   \"de\"     \n[8] \"la\"      \"semana.\"\n\n[[4]]\n [1] \"Agrega\"   \"a\"        \"la\"       \"cuenta\"   \"de\"       \"la\"      \n [7] \"tienda\"   \"hasta\"    \"el\"       \"último\"   \"centavo.\"\n\n[[5]]\n[1] \"Nueve\"       \"hombres\"     \"fueron\"      \"contratados\" \"para\"       \n[6] \"excavar\"     \"las\"         \"ruinas.\"    \n```\n:::\n:::\n\n\nComo cada componente podría tener un número diferente de elementos, esto devuelve una lista. Si estás trabajando con vectores de extensión 1, lo más fácil es extraer el primer elemento de la lista:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"a|b|c|d\" %>% \n  str_split(\"\\\\|\") %>% \n  .[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n:::\n:::\n\n\nOtra opción es, al igual que con otras funciones de __stringr__ que devuelven una lista, utilizar `simplify = TRUE` para obtener una matriz:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noraciones %>%\n  head(5) %>% \n  str_split(\" \", simplify = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]     [,2]      [,3]     [,4]          [,5]    [,6]        [,7]    \n[1,] \"Las\"    \"casas\"   \"están\"  \"construidas\" \"de\"    \"ladrillos\" \"de\"    \n[2,] \"La\"     \"caja\"    \"fue\"    \"arrojada\"    \"al\"    \"lado\"      \"del\"   \n[3,] \"El\"     \"domingo\" \"es\"     \"la\"          \"mejor\" \"parte\"     \"de\"    \n[4,] \"Agrega\" \"a\"       \"la\"     \"cuenta\"      \"de\"    \"la\"        \"tienda\"\n[5,] \"Nueve\"  \"hombres\" \"fueron\" \"contratados\" \"para\"  \"excavar\"   \"las\"   \n     [,8]      [,9]           [,10]    [,11]     \n[1,] \"arcilla\" \"roja.\"        \"\"       \"\"        \n[2,] \"camión\"  \"estacionado.\" \"\"       \"\"        \n[3,] \"la\"      \"semana.\"      \"\"       \"\"        \n[4,] \"hasta\"   \"el\"           \"último\" \"centavo.\"\n[5,] \"ruinas.\" \"\"             \"\"       \"\"        \n```\n:::\n:::\n\n\nTambién puedes indicar un número máximo de elementos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncampos <- c(\"Nombre: Hadley\", \"País: NZ\", \"Edad: 35\")\ncampos %>% str_split(\": \", n = 2, simplify = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]     [,2]    \n[1,] \"Nombre\" \"Hadley\"\n[2,] \"País\"   \"NZ\"    \n[3,] \"Edad\"   \"35\"    \n```\n:::\n:::\n\n\nEn vez de dividir una cadena según patrones, puedes hacerlo según caracter, línea, oración o palabra. Para ello, puedes utilizar la función `boundary()` (_límite_). En el siguiente ejemplo la división se hace por palabra (_word_):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"Esta es una oración. Esta es otra oración.\"\nstr_view_all(x, boundary(\"word\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <Esta> <es> <una> <oración>. <Esta> <es> <otra> <oración>.\n```\n:::\n\n```{.r .cell-code}\nstr_split(x, \" \")[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Esta\"     \"es\"       \"una\"      \"oración.\" \"Esta\"     \"es\"       \"otra\"    \n[8] \"oración.\"\n```\n:::\n\n```{.r .cell-code}\nstr_split(x, boundary(\"word\"))[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Esta\"    \"es\"      \"una\"     \"oración\" \"Esta\"    \"es\"      \"otra\"   \n[8] \"oración\"\n```\n:::\n:::\n\n\n#### Ejercicios\n\n1.  Divide una cadena como `\"manzanas, peras y bananas\"` en elementos\n    individuales.\n    \n1.  ¿Por qué es mejor dividir utilizando `boundary(\"word\")` en vez de `\" \"`?\n\n1.  ¿Qué pasa si dividimos con una cadena vacía (`\"\"`)? Experimenta y\n    luego lee la documentación\n\n### Buscar coincidencias\n\n`str_locate()` y `str_locate_all()` te indican la posición inicial y final de una coincidencia. Son particularmente útiles cuando ninguna otra función hace exactamente lo que quieres. Puedes utilizar `str_locate()` para encontrar los patrones de coincidencia y `str_sub()` para extraerlos y/o modificarlos.\n\n## Otro tipo de patrones\n\nCuando utilizas un patrón que es una cadena, este automáticamente es encapsulado en la función `regex()` (_regex_ es la forma abreviada de _regular expression_, es decir, expresión regular):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# La manera regular en que escribimos el patrón\nstr_view(frutas, \"nana\")\n# Es un atajo de\nstr_view(frutas, regex(\"nana\"))\n```\n:::\n\n\nPuedes utilizar los otros argumentos de `regex()` para controlar los detalles de la coincidencia:\n\n*   `ignore_case = TRUE` permite que la búsqueda coincida tanto con caracteres en mayúscula\n    como en minúscula. Este argumento siempre utiliza los parámetros de tu _locale_.\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    bananas <- c(\"banana\", \"Banana\", \"BANANA\")\n    str_view(bananas, \"banana\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] │ <banana>\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    str_view(bananas, regex(\"banana\", ignore_case = TRUE))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] │ <banana>\n    [2] │ <Banana>\n    [3] │ <BANANA>\n    ```\n    :::\n    :::\n\n    \n*   `multiline = TRUE` permite que `^` y `$` coincidan con el inicio y fin de cada\n    línea, en vez del inicio y fin de la cadena completa.\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- \"Línea 1\\nLínea 2\\nLínea 3\"\n    str_extract_all(x, \"^Línea\")[[1]]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"Línea\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    str_extract_all(x, regex(\"^Línea\", multiline = TRUE))[[1]]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"Línea\" \"Línea\" \"Línea\"\n    ```\n    :::\n    :::\n\n    \n*   `comments = TRUE` te permite utilizar comentarios y espacios en blanco\n    para hacer más entendibles las expresiones regulares complejas.\n    Los espacios son ignorados, al igual que todo lo que está después de \n    `#`. Para coincidir un espacio de manera literal, tendrías que \n    \"escaparlo: `\"\\\\ \"`.\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    telefono <- regex(\"\n      \\\\(?     # paréntesis inicial opcional\n      (\\\\d{3}) # código de área\n      [) -]?   # paréntesis, espacio o guión inicial opcional\n      (\\\\d{3}) # otros tres números\n      [ -]?    # espacio o guión opcional\n      (\\\\d{3}) # otros tres números\n      \", comments = TRUE)\n    \n    str_match(\"514-791-8141\", telefono)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n         [,1]          [,2]  [,3]  [,4] \n    [1,] \"514-791-814\" \"514\" \"791\" \"814\"\n    ```\n    :::\n    :::\n\n\n*   `dotall = TRUE` permite que `.` coincida con todo, incluidos los saltos de línea (`\\n`).\n\nExisten otras tres funciones que puedes utilizar en vez de `regex()`:\n\n*   `fixed()`: busca una coincidencia exacta de la secuencia de bytes especificada.\n    Ignora todas las expresiones regulares especiales y opera a un nivel muy bajo. \n    Esto te permite evitar formas de \"escapado\" complejas y puede ser mucho\n    más rápida que las expresiones regulares. La comparación utilizando\n    `microbenchmark` muestra que `fixed()` es casi dos veces más rápida.\n  \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    #install.packages(microbenchmark)\n    microbenchmark::microbenchmark(\n      fixed = str_detect(oraciones, fixed(\"la\")),\n      regex = str_detect(oraciones, \"la\"),\n      times = 20\n    )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Unit: microseconds\n      expr    min     lq     mean  median      uq     max neval cld\n     fixed 18.737 19.639 32.65360 20.2145 21.7845 240.371    20   a\n     regex 20.707 21.161 27.10185 22.5515 26.8100  82.757    20   a\n    ```\n    :::\n    :::\n\n    \n    IMPORTANTE: ten precaución al utilizar `fixed()` con datos que no estén en inglés. Puede causar problemas porque\n    muchas veces existen múltiples formas de representar un mismo caracter. Por \n    ejemplo, hay dos formas de difinir \"á\": como un solo caracter o como una\n    \"a\" con un acento:\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a1 <- \"\\u00e1\"\n    a2 <- \"a\\u0301\"\n    c(a1, a2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"á\" \"á\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    a1 == a2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] FALSE\n    ```\n    :::\n    :::\n\n\n    Ambas se _renderean_ de manera idéntica, pero como están definidas de manera distinta, \n    `fixed()` no encuentra una coincidencia. En su lugar, puedes utilizar `coll()`, que definiremos a continuación, ya que respeta las reglas humanas de comparación de caracteres:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    str_detect(a1, fixed(a2))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] FALSE\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    str_detect(a1, coll(a2))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] TRUE\n    ```\n    :::\n    :::\n\n    \n*   `coll()`: compara cadenas usando reglas de secuenciación (_collation_) estándar. Esto es \n    útil para buscar coincidencias que sean insensibles a mayúsculas y minúsculas. Ten en cuenta que `coll()` incluye un parámetro para el _locale_, \n    Lamentablemente, se utilizan diferentes reglas en diferentes partes del mundo. \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # Esto quiere decir que también tienes que prestar atención a esas \n    # diferencias al buscar coincidencias insensibles a mayúsculas y\n    # minúsculas\n    i <- c(\"I\", \"İ\", \"i\", \"ı\")\n    i\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"I\" \"İ\" \"i\" \"ı\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    str_subset(i, coll(\"i\", ignore_case = TRUE))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"I\" \"i\"\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    str_subset(i, coll(\"i\", ignore_case = TRUE, locale = \"tr\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"İ\" \"i\"\n    ```\n    :::\n    :::\n\n    \n    Tanto `fixed()` como `regex()` tienen argumentos para ignorar la\n    diferencia entre mayúsculas y minúsculas (`ignore_case`); sin embargo, \n    no te permiten elegir tu _locale_: siempre utilizan el que está definido\n    por defecto. Puedes ver cuál se está usando con el siguiente código. Pronto\n    hablaremos más sobre el paquete __stringi__. \n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    stringi::stri_locale_info()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    $Language\n    [1] \"en\"\n    \n    $Country\n    [1] \"CA\"\n    \n    $Variant\n    [1] \"\"\n    \n    $Name\n    [1] \"en_CA\"\n    ```\n    :::\n    :::\n\n    \n    Una desventaja de `coll()` es la velocidad. Debido a que las reglas para\n    reconocer qué caracteres son iguales suelen ser complicadas, `coll()` es\n    relativamente más lenta al compararla con `regex()` y `fixed()`.\n\n*   Como viste con `str_split()`, puedes utilizar `boundary()` para\ncoincidir límites. \n    También puedes utilizarla con otras funciones:\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- \"Esta es una oración.\"\n    str_view_all(x, boundary(\"word\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] │ <Esta> <es> <una> <oración>.\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    str_extract_all(x, boundary(\"word\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [[1]]\n    [1] \"Esta\"    \"es\"      \"una\"     \"oración\"\n    ```\n    :::\n    :::\n\n\n### Ejercicios\n\n1.  ¿Cómo buscarías todas las cadenas que contienen `\\` con `regex()` vs.\n    con `fixed()`?\n\n1.  ¿Cuáles son las cinco palabras más comunes en `oraciones`?\n\n## Otros usos de las expresiones regulares. \n\nExisten dos funciones útiles en R base que también utilizan expresiones regulares: \n\n*   `apropos()` busca todos los objetos disponibles en el ambiente global\n(_global environment_). Esto\n    es útil si no recuerdas bien el nombre de una función.\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    apropos(\"replace\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"%+replace%\"       \"replace\"          \"replace_na\"       \"setReplaceMethod\"\n    [5] \"str_replace\"      \"str_replace_all\"  \"str_replace_na\"   \"theme_replace\"   \n    ```\n    :::\n    :::\n\n    \n*   `dir()` entrega una lista con todos los archivos en un directorio. El argumento\n    `pattern` recibe una expresión regular y retorna solo los \n    nombres de archivos que coinciden con ese patrón. \n    Por ejemplo, puedes encontrar todos los archivos de R Markdown en el \n    directorio actual con: \n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    head(dir(pattern = \"\\\\.Rmd$\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    character(0)\n    ```\n    :::\n    :::\n\n    \n    (Si te resulta más cómodo trabajar con \"globs\", es decir, especificar \n    los nombres de archivo utilizando comodines, como en `*.Rmd`, puedes\n    convertirlos a expresiones regulares con la función `glob2rx()`)\n\n## stringi\n\n__stringr__ está construido sobre la base del paquete __stringi__. __stringr__ es útil cuando estás aprendiendo, ya que presenta un set mínimo de funciones, que han sido elegidas cuidadosamente para manejar las funciones de manipulación de cadenas más comunes. __stringi__, por su parte, está diseñado para ser comprehensivo. Contiene casi todas las funciones que podrías necesitar: __stringi__ tiene 256 funciones, frente a las 59 de __stringr__.\n\nSi en algún momento te encuentras en dificultades para hacer algo en __stringr__ , vale la pena darle una mirada a __stringi__. Ambos paquetes funcionan de manera muy similar, por lo que deberías poder traducir tu conocimiento sobre __stringr__ de manera natural. La principal diferencia es el prefijo: `str_` vs. `stri_`.\n\n### Ejercicios\n\n1.  Busca la función de __stringi__ que:\n\n    1. Cuenta el número de palabras.\n    1. Busca cadenas duplicadas.\n    1. Genera texto aleatorio.\n\n1.  ¿Cómo puedes controlar qué lengua usa `stri_sort()` para ordenar?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}